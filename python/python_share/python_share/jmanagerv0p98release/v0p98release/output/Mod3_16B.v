//----------------------------------------------------------------------------
// Copyright 2023 JoulWatt  
// Generated by Jmanager V0.98 @2023-12-26 15:40:20
// The copyright of this code belongs to JOULWATT Company and cannot be held or distributed
// without authorization. If you are not authorized, please delete this code immediately.
//----------------------------------------------------------------------------
module Mod3_16B  #(
    parameter W_WD = 16,
    parameter A_WD = 4
)  (
    input                   clk     ,
    input                   rst_n   ,
    input                   cs      , // 1: reg module is selected the read and write will be done
    input                   we      , // 1: write enable 
    input                   re      , // 1: read  enable 
    input   [A_WD-1:0]      addr,
    input   [W_WD-1:0]      w_dat,
   //-----------std io done ----------------
    input                   reg444d, //default_v=0x0x0
    input                   reg444e, //default_v=0x0x0
    input  [1:0]            reg444f, //default_v=0x0x0
    input  [3:0]            m2r4_ro_3b, //default_v=0x0x0
    input  [15:0]           ro0x6_8b, //default_v=0x0x1
    output  [9:0]           ab ,
    output  [2:0]           reg3to2d ,
    output                  reg00d ,
    output  [9:0]           ac ,
    output  [2:0]           reg3to2e ,
    output                  reg00e ,
    output  [9:0]           add ,
    output                  reg00f ,
    output  [9:0]           eaaee4 ,
    output                  m2r4_f0 ,
    output  [15:0]          rw0x5_8b ,
    output  [15:0]          rw0x7_8b ,
    output  reg [W_WD-1: 0]   dout,
    output  reg [W_WD-1: 0]   dout_com
);//io define end


//regs----inst: REG0B Default_Value:0x46------
wire  we_en_0 = (addr == 4'h0) & cs & we ;
wire  [W_WD-1:0]    reg_out_0 = { ab,1'h0,reg444d,reg3to2d,reg00d };

reg_rw #(.BITS_W  (14), .DEFAULT_V  (14'h16))   U_REG0B_0 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_0),
    .w_dat     ({w_dat[15:6],w_dat[3:1],w_dat[0]}),
    .dout     ({ab,reg3to2d,reg00d}));

//regs----inst: REG2B Default_Value:0x46------
wire  we_en_1 = (addr == 4'h1) & cs & we ;
wire  [W_WD-1:0]    reg_out_1 = { ac,1'h0,reg444e,reg3to2e,reg00e };

reg_rw #(.BITS_W  (14), .DEFAULT_V  (14'h16))   U_REG2B_1 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_1),
    .w_dat     ({w_dat[15:6],w_dat[3:1],w_dat[0]}),
    .dout     ({ac,reg3to2e,reg00e}));

//regs----inst: REG3B Default_Value:0x40------
wire  we_en_2 = (addr == 4'h2) & cs & we ;
wire  [W_WD-1:0]    reg_out_2 = { add,3'h0,reg444f,reg00f };

reg_rw #(.BITS_W  (11), .DEFAULT_V  (11'h2))   U_REG3B_2 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_2),
    .w_dat     ({w_dat[15:6],w_dat[0]}),
    .dout     ({add,reg00f}));

//regs----inst: REG4B Default_Value:0x40------
wire  we_en_3 = (addr == 4'h3) & cs & we ;
wire  [W_WD-1:0]    reg_out_3 = { eaaee4,1'h0,m2r4_ro_3b,m2r4_f0 };

reg_rw #(.BITS_W  (11), .DEFAULT_V  (11'h2))   U_REG4B_3 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_3),
    .w_dat     ({w_dat[15:6],w_dat[0]}),
    .dout     ({eaaee4,m2r4_f0}));

//regs----inst: REG5B Default_Value:0xfb------
wire  we_en_4 = (addr == 4'h4) & cs & we ;
wire  [W_WD-1:0]    reg_out_4 = { rw0x5_8b };

reg_rw #(.BITS_W  (16), .DEFAULT_V  (16'hfb))   U_REG5B_4 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_4),
    .w_dat     ({w_dat[15:0]}),
    .dout     ({rw0x5_8b}));

//regs----inst: REG6B Default_Value:0x1------


//regs----inst: REG6B Default_Value:0x1------
wire  [W_WD-1:0]    reg_out_6 = { ro0x6_8b };


//regs----inst: REG7B Default_Value:0x1------
wire  we_en_7 = (addr == 4'h7) & cs & we ;
wire  [W_WD-1:0]    reg_out_7 = { rw0x7_8b };

reg_rw #(.BITS_W  (16), .DEFAULT_V  (16'h1))   U_REG7B_7 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_7),
    .w_dat     ({w_dat[15:0]}),
    .dout     ({rw0x7_8b}));

//regs out mux , dout is buffed with reg, dout_com is not!
always@(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0) 
        dout <= {(W_WD){1'b0}};
    else if(cs & re ) begin
        case(addr) 
            4'h0:  dout <= reg_out_0;
            4'h1:  dout <= reg_out_1;
            4'h2:  dout <= reg_out_2;
            4'h3:  dout <= reg_out_3;
            4'h4:  dout <= reg_out_4;
            4'h6:  dout <= reg_out_6;
            4'h7:  dout <= reg_out_7;
            default: dout <= {(W_WD){1'b0}};
        endcase
    end
    else begin
        dout <= {(W_WD){1'b0}};
    end
end


//regs out mux , dout is buffed with reg, dout_com is not!
always@(*) begin
    if(cs & re) begin
        case(addr) 
            4'h0:  dout_com = reg_out_0;
            4'h1:  dout_com = reg_out_1;
            4'h2:  dout_com = reg_out_2;
            4'h3:  dout_com = reg_out_3;
            4'h4:  dout_com = reg_out_4;
            4'h6:  dout_com = reg_out_6;
            4'h7:  dout_com = reg_out_7;
            default: dout_com  = {(W_WD){1'b0}};
        endcase
    end
    else begin
        dout_com = {(W_WD){1'b0}};
    end
end
endmodule
