//----------------------------------------------------------------------------
// Copyright 2023 JoulWatt  
// Generated by Jmanager V0.98 @2023-12-26 15:40:20
// The copyright of this code belongs to JOULWATT Company and cannot be held or distributed
// without authorization. If you are not authorized, please delete this code immediately.
//----------------------------------------------------------------------------
module Mod1  #(
    parameter W_WD = 8,
    parameter A_WD = 8
)  (
    input                   clk     ,
    input                   rst_n   ,
    input                   cs      , // 1: reg module is selected the read and write will be done
    input                   w1c_clr , // 1: clr all w1c type regs 
    input                   we      , // 1: write enable 
    input                   re      , // 1: read  enable 
    input   [A_WD-1:0]      addr,
    input   [W_WD-1:0]      w_dat,
   //-----------std io done ----------------
    input                   reg444ba, //default_v=0x0x1
    input  [1:0]            reg444b, //default_v=0x0x0
    input  [1:0]            field5c_trig,
    input                   reg444c_trig,
    input                   reg00c_trig,
    input  [1:0]            field5c12, //default_v=0x0x0
    input  [7:0]            reg21w1c_trig,
    input                   busy_trig,
    input                   off, //default_v=0x0x0
    input                   vout_ov_fault, //default_v=0x0x0
    input                   iout_oc_fault, //default_v=0x0x0
    input                   vin_uv_fault, //default_v=0x0x3
    input                   tempereature, //default_v=0x0x0
    input                   cml, //default_v=0x0x0
    input                   none_of_the_above, //default_v=0x0x0
    output  [1:0]           field5a ,
    output  [2:0]           reg3to2a ,
    output                  reg00a ,
    output  [1:0]           field5b ,
    output  [1:0]           reg3to2b ,
    output                  reg00ab ,
    output  [1:0]           field5c ,
    output                  reg444c ,
    output                  reg00c ,
    output  [5:0]           reg00c12 ,
    output  [7:0]           xx_name ,
    output  [7:0]           reg9e_name2 ,
    output  [7:0]           reg21w1c ,
    output                  busy ,
    output  reg [W_WD-1: 0]   dout,
    output  reg [W_WD-1: 0]   dout_com
);//io define end


//regs----inst: REG0 Default_Value:0x18------
wire  we_en_0 = (addr == 8'h0) & cs & we ;
wire  [W_WD-1:0]    reg_out_0 = { field5a,1'h0,reg444ba,reg3to2a,reg00a };

reg_rw #(.BITS_W  (6), .DEFAULT_V  (6'h8))   U_REG0_0 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_0),
    .w_dat     ({w_dat[7:6],w_dat[3:1],w_dat[0]}),
    .dout     ({field5a,reg3to2a,reg00a}));

//regs----inst: REG2 Default_Value:0x6------
wire  we_en_1 = (addr == 8'h1) & cs & we ;
wire  [W_WD-1:0]    reg_out_1 = { field5b,1'h0,reg444b,reg3to2b,reg00ab };

reg_rw #(.BITS_W  (5), .DEFAULT_V  (5'h6))   U_REG2_1 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_1),
    .w_dat     ({w_dat[7:6],w_dat[2:1],w_dat[0]}),
    .dout     ({field5b,reg3to2b,reg00ab}));

//regs----inst: REG3 Default_Value:0x0------
wire  we_en_3 = (addr == 8'h3) & cs & we ;
wire  [W_WD-1:0]    reg_out_3 = { field5c,2'h0,reg444c,2'h0,reg00c };

reg_w1c #(.BITS_W  (4))   U_REG3_3 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_3),
    .clr      (w1c_clr),
    .w_dat     ({w_dat[7:6],w_dat[3],w_dat[0]}),
    .trig     ({field5c_trig,reg444c_trig,reg00c_trig}),
    .dout     ({field5c,reg444c,reg00c}));

//regs----inst: REG1C Default_Value:0x0------
wire  we_en_1c = (addr == 8'h1c) & cs & we ;
wire  [W_WD-1:0]    reg_out_1c = { field5c12,reg00c12 };

reg_rw #(.BITS_W  (6), .DEFAULT_V  (6'h0))   U_REG1C_1C (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_1c),
    .w_dat     ({w_dat[5:0]}),
    .dout     ({reg00c12}));

//regs----inst: REG1D Default_Value:0x9e------
wire  we_en_1d = (addr == 8'h1d) & cs & we ;
wire  [W_WD-1:0]    reg_out_1d = { xx_name };

reg_rw #(.BITS_W  (8), .DEFAULT_V  (8'h9e))   U_REG1D_1D (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_1d),
    .w_dat     ({w_dat[7:0]}),
    .dout     ({xx_name}));

//regs----inst: REG1F Default_Value:0x9e------
wire  we_en_1f = (addr == 8'h1f) & cs & we ;
wire  [W_WD-1:0]    reg_out_1f = { reg9e_name2 };

reg_rw #(.BITS_W  (8), .DEFAULT_V  (8'h9e))   U_REG1F_1F (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_1f),
    .w_dat     ({w_dat[7:0]}),
    .dout     ({reg9e_name2}));

//regs----inst: REG21_W1C Default_Value:0x0------
wire  we_en_21 = (addr == 8'h21) & cs & we ;
wire  [W_WD-1:0]    reg_out_21 = { reg21w1c };

reg_w1c #(.BITS_W  (8))   U_REG21_W1C_21 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_21),
    .clr      (w1c_clr),
    .w_dat     ({w_dat[7:0]}),
    .trig     ({reg21w1c_trig}),
    .dout     ({reg21w1c}));

//regs----inst: STATUS_BYTE Default_Value:0x18------
wire  we_en_33 = (addr == 8'h33) & cs & we ;
wire  [W_WD-1:0]    reg_out_33 = { busy,off,vout_ov_fault,iout_oc_fault,vin_uv_fault,tempereature,cml,none_of_the_above };

reg_w1c #(.BITS_W  (1))   U_STATUS_BYTE_33 (
    .clk      (clk),
    .rst_n    (rst_n),
    .w_en     (we_en_33),
    .clr      (w1c_clr),
    .w_dat     ({w_dat[7]}),
    .trig     ({busy_trig}),
    .dout     ({busy}));

//regs out mux , dout is buffed with reg, dout_com is not!
always@(posedge clk or negedge rst_n) begin
    if(rst_n == 1'b0) 
        dout <= {(W_WD){1'b0}};
    else if(cs & re ) begin
        case(addr) 
            8'h0:  dout <= reg_out_0;
            8'h1:  dout <= reg_out_1;
            8'h3:  dout <= reg_out_3;
            8'h1c:  dout <= reg_out_1c;
            8'h1d:  dout <= reg_out_1d;
            8'h1f:  dout <= reg_out_1f;
            8'h21:  dout <= reg_out_21;
            8'h33:  dout <= reg_out_33;
            default: dout <= {(W_WD){1'b0}};
        endcase
    end
    else begin
        dout <= {(W_WD){1'b0}};
    end
end


//regs out mux , dout is buffed with reg, dout_com is not!
always@(*) begin
    if(cs & re) begin
        case(addr) 
            8'h0:  dout_com = reg_out_0;
            8'h1:  dout_com = reg_out_1;
            8'h3:  dout_com = reg_out_3;
            8'h1c:  dout_com = reg_out_1c;
            8'h1d:  dout_com = reg_out_1d;
            8'h1f:  dout_com = reg_out_1f;
            8'h21:  dout_com = reg_out_21;
            8'h33:  dout_com = reg_out_33;
            default: dout_com  = {(W_WD){1'b0}};
        endcase
    end
    else begin
        dout_com = {(W_WD){1'b0}};
    end
end
endmodule
